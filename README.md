# design-pattern
**设计模式：**
UML:
  定义：1.统一建模语言(Unified Modeing Language)
       2.非专利的第三代建模和规约语言
  特点：
      1.UML是一种开发的方法
      2.用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法
      3.UML展现了一系列最佳工程实践,这些最佳工程实践，在对大规模、复杂系统进行建模方面，特别在软件架构层次已经被验证有效
  分类：
      1.结构式图形:强调的是系统式建模
        1)静态图(类图、对象图、包图)
        2)实现图(组件图、部署图)
        3)剖面图
        4)复合结构图
      2.行为式图形:强调系统模型中触发的事件
        1)活动图
        2)状态图
        3)用例图
      3.交互式图形:属于行为式图形子集合，强调系统模型中资料流程
        1)通信图
        2)交互概述图(UML2.0)
        3)时序图(UML2.0)
        4)时间图(UML2.0)
   UML类图：
    1.class diagram:用于表示类、接口、实例等之间相互的静态关系
    2.虽然名字叫类图，但类图中并不只有类
   UML时序图:
7大设计原则:
    开闭原则(open close principle)：
        * 定义：对扩展开发，对修改关闭
        * 优点：提高系统的可用性和可扩展性
    依赖倒置原则(dependence inversion principle)：
        * 定义:高层不应该依赖低层模块，两者应依赖其抽象
        * 抽象不应该依赖细节，细节应该依赖抽象
        * 面向接口编程，不是面向实现编程
    单一职责原则(single responsibility principle):
         * 定义：不要存在多于一个导致类变更的原因
         * 1个类/接口/方法只负责一个职责
         * 优点：降低类的复杂度、提供类的可读性、提供系统的可维护性、降低变更引起的风险
    接口隔离原则(interface segregation principle )：
         * 定义：用多个专门的接口，而不使用一个总的接口
         * 一个类对另一个类的依赖应该建立在最小的接口
         * 建议单一的接口，不要建立庞大臃肿的接口
         * 遵循适度原则，一定要适度
         * 优点：高内聚低耦合，具有很好的可读性、可扩展性、可维护性
    里氏替换原则(liskov substitution principle)：
         * 定义：
         * 1.如果对每个类型为T1的对象O1,都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都替换为O2，
         * 程序P的行为没有发生变化，那么类型T2是T1类型的子类型
         *
         * 定义扩展：
         * 一个软件实体如果适用一个父类的话，那么一定适用于其子类，
         * 所有引用父类的地方必须能透明的使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变
         *
         * 引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能
         * 含义：
         * 1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
         * 2：子类中可以增加自己特有的方法
         * 3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类的输入参考更宽松
         * 4：当子类的方法实现父类方法时(重载、重写、实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或相等
    合成复用原则(composition aggregation principle)：
         * 定义：尽量使用对象组合/聚合，而不使用继承达到软件复用的目的
         * 聚合has-A关系、组合contains-A 、继承 is-A
         * 优点：可以使系统更加灵活，降低了类与类直接的耦合度，一个类的变化对其他类影响较小
    迪米特原则(demeter principle):
         * 定义：1个类应该保持对另一个类最少了解，即最少知道原则
         * 优点：降低类与类直接的耦合
         * 强调只和朋友说话，不和陌生人说话
         * 朋友：出现在成员变量、输入参数、输出参数
         * 而出现在方法体内部的类是陌生人

设计模式
    创建型(creational):
        0.简单工厂模式(simple factory)：
             * 定义：由一个工厂对象决定创建哪一种产品类的实例
             * 类型：属于创建型，不属于GOF 23种设计模式
             * 使用场景：
             * 1.工厂类负责创建的对象比较少
             * 2.客户端(应用层)只负责传入工厂类的参数，对于如何创建对象不关心
             * 优点：只需要传入一个参数就可以获取你需要的对象，无需知道创建细节
             * 缺点：工厂类的职责相对过重，如果增加新的产品，需要修改工厂类的判断逻辑，违背开闭原则
        1.工厂方法模式(factory method)：
             * 定义：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行
             * 类型：属于创建型
             * 使用场景：
             * 1.创建对象需要大量的重复代码，
             * 2.客户端(应用层)不依赖产品实例如何被创建、实现等细节
             * 3.一个类通过其子类来制定创建哪个对象
             * 优点：
             * 1.用户只需关心产品对应的工厂，无法关心创建细节
             * 2.加入新的产品符合开闭原则，提供可扩展性
             * 缺点：
             * 1.类的个数过多，增加复杂度
             * 2.增加了系统的抽象性和理解难度
        2.原型模式(prototype):
             * 定义:指原型对象创建实例的种类，并且通过拷贝这些原型创建新的对象
             * 不需要知道任何创建的细节，不调用构造函数
             *
             * 类型：创建型
             *
             * 适用场景：
             * 1.类初始化消耗较多资源
             * 2.new产生的一个对象需要非常繁琐的过程(数据准备、访问权限)
             * 3.构造函数比较复杂
             * 4.循环体中产生大量对象时
             *
             * 优点：
             * 1.原型模式性能比new一个对象性能高
             * 2.简化创建过程
             *
             * 缺点:
             * 1.必须配备克隆方法
             * 2.对克隆复杂对象或对克隆对象进行复杂改造时，容易引起风险
             * 3.浅拷贝和深拷贝要运用得当
        3.建造者模式(builder):
             * 定义：将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示
             * 用户只需指定需要建造的类型就可以得到他们，建造过程和细节不需要知道
             * 类型：创建型
             *
             * 适用场景：
             * 1.一个对象有非常复杂的内部结构(很多属性)
             * 2.想把复杂对象的创建和使用分离
             *
             * 优点：
             * 1.封装性好，创建和使用分离
             * 2.扩展性好、建造者之间独立，一定程度上解耦
             *
             * 缺点：
             * 1.产生多余的builder对象
             * 2.产品内部发生变化，建造者都要修改，成本较大
        4.抽象工厂模式(abstract factory):
             * 定义：
             * 1.提供创建一系列或相互依赖对象的接口，无需指定他们具体的类
             * 类型：创建型
             * 适用场景：
             * 1.客户端不依赖产品实例如何创建、实现等细节
             * 2.强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码
             * 3.提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖具体的实现
             * 优点：
             * 1.具体产品在应用层代码隔离，无须关心创建细节
             * 2.将一系列产品族统一到一起创建
             * 缺点：
             * 1.规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
             * 2.增加系统的抽象性和理解难度
        5.单例模式(singleton):
        `   * 定义:保证一个类仅有一个实例，提供一个全局访问点
            *
            * 类型：创建型
            *
            * 适用场景：
            * 1.想确保任何情况下都绝对只有一个实例
            *
            * 优点：
            * 1.在内存中只有一个实例，减少了内存开销
            * 2.可以避免对资源的多重占用
            * 3.设置全局访问点,严格控制访问
            *
            * 重点：
            * 1.私有构造器
            * 2.线程安全：DoubleCheck双重检查实战
            * 3.延迟加载：
            * 4.序列化和反序列化安全：序列化破坏单例模式原理解析及解决方案 
            * 5.反射：反射攻击解决方案及原理分析
            * 懒汉式、饿汉式
            * 静态内部类-基于类初始化的延迟加载解决方案
            * Enum枚举单例、原理源码解析以及反编译实战 
            * 容器单例 
            * ThreadLocal线程单例 
    结构型(structural):
        适配器模式(adapter)：
             * 定义：
             * 1.将一个类的接口转换成客户期望的另一个接口
             * 2.使原本接口不兼容的类可以一起工作
             *
             * 类型：结构型
             *
             * 适用场景：
             * 1.已经存在的类，它的方法和需求不匹配时(方法结果相同或相似)
             * 2.不是软件设计阶段考虑的设计模式，而是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案
             *
             * 优点：
             * 1.能提高类的透明性和复用，现有的类复用但不需要改变
             * 2.目标类与适配器解耦，提高程序扩展性
             * 3.符合开闭原则
             *
             * 缺点：
             * 1.适配器编写过程需要全面考虑， 可能会增加系统的复杂性
             * 2.增加系统代码可读的难度
             *
             * 扩展：
             * 类适配器、对象适配器、接口适配器
        桥接模式(bridge):
             * 定义：
             * 1.将抽象部分与它的具体实现部分分离，使他们都可以独立的变化
             * 2.通过组合的方式建立两个类之间的联系，而不是继承
             *
             * 类型：结构型
             *
             * 适用场景：
             * 1.抽象和具体实现之间增加更多的灵活性
             * 2.一个类存在两个(或多个)独立变化的纬度，且这两个(或多个)纬度都需要独立进行扩展
             * 3.不希望继承，或因为多层继承导致系统类个数剧增
             *
             * 优点：
             * 1.分离抽象部分和具体实现部分
             * 2.提高了系统的可扩展性
             * 3.符合开闭原则
             * 4.符合合成复用原则
             *
             * 缺点：
             * 1.增加了系统的理解和设计难度
             * 2.需正确地识别出系统中两个独立变化的维护
        享元模式(flyweight):
             * 定义：提供了减少对象数量从而改善应用所需的对象结构的方式
             * 运用共享技术有效的支持大量细粒度的对象
             *
             * 类型：结构型
             *
             * 适用场景：
             * 1.常常应用于系统底层的开发，以便解决系统的性能问题
             * 2.系统需要大量相似对象，类似缓冲池的场景
             *
             * 优点：
             * 1.减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
             * 2.减少内存之外的其他资源的占用
             *
             * 缺点：
             * 1.关注内部/外部状态 关注线程安全问题
             * 2.使系统、程序的逻辑复杂化
             *
             * 扩展：
             * 内部状态/外部状态
        外观模式(facade)：
             * 定义：
             * 1.又叫门面模式，提供了一个统一的接口，用来访问子系统的一群接口
             * 外观模式定义了一个高层接口，让系统更容易使用
             * 类型：结构型
             *
             * 适用场景：
             * 1.子系统越来越复杂，增加外观模式提供简单的接口调用
             * 2.构建多层系统结构，利用外观对象作为每层的入口，简化层间调用
             *
             * 优点：
             * 1.简化了调用过程，无需深入了解子系统，阻止带来风险
             * 2.减少系统依赖，松散耦合
             * 3.更好的划分访问层次
             * 4.符合迪米特法则，即最少知道原则
             *
             * 缺点：
             * 1.扩展子系统，增加子系统行为容易引入风险
             * 2.不符合开闭原则
        代理模式(proxy)：
             * 定义：为其他对象提供一种代理，以控制该对象的访问
             * 代理对象在客户端和目标对象中起到中介的作用
             *
             * 适用场景：
             * 1.保护目标对象
             * 2.增加目标对象
             *
             * 优点：
             * 1.代理模式将代理对象与真实被调用的目标对象分离
             * 2.一定程度上降低了系统的耦合度，扩展性好
             * 3.保护目标对象
             * 4.增强目标对象
             *
             * 缺点：
             * 1.代理模式中会造成系统设计中类的数目增加
             * 2.在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢
             * 3.增加系统复杂性
             *
             * 扩展：
             * 1.静态代理
             * 2.动态代理
             * 3.CGLIB代理
        装饰者模式(decorator):
             * 定义：在不改变原有对象的基础之上，将功能附加到对象上
             * 提供了比继承更有弹性的替代方案(扩展原有对象的功能)
             *
             * 类型：结构型
             *
             * 适用场景：
             * 1.扩展一个类的功能或给一个类添加附加职责
             * 2.动态给一个对象添加功能，这些功能可以动态的撤销
             *
             * 优点：
             * 1.继承的有力补充，比继承更灵活，在不改变一个对象的前提下给一个对象扩展功能
             * 2.通过使用不同装饰类或这些装饰类的排列组合，可以实现不同效果
             * 3.符合开闭原则
             *
             * 缺点：
             * 1.会出现更多的代码，更多的类，增加程序复杂性
             * 2.动态装饰时，多层装饰时会更复杂
        组合模式(composite)：
             * 1.将对象组合成树形结构以表示“部分-整体”的层次结构
             * 2.组合模式使客户端对单个对象和组合对象保持一致的方式处理
             *
             * 类型：结构型
             *
             * 适用场景：
             * 1.希望客户端可以忽略组合对象和单个对象的差异
             * 2.处理一个树形结构时
             *
             * 优点：
             * 1.清楚地定义分层次的复杂对象，表示对象的全部或部分层次
             * 2.让客户端忽略了层次的差异，方便对整个层次进行控制
             * 3.简化客户端代码
             * 4.符合开闭原则
             *
             *
             * 缺点：
             * 1.限制类型时会较为复杂
             * 2.使设计变得更加抽象
    行为型模式(behavioral):
        策略模式(strategy):
             * 定义：
             * 1.定义了算法家族，分别封装起来，让他们之间可以相互替换
             * 次模式让算法的变化不会影响到使用算法的用户
             * 2.if...else..
             *
             * 适用场景：
             * 1.系统有很多类，而他们的区别仅仅在于他们的行为不同
             * 2.一个系统需要动态地在几种算法中选择一种
             *
             * 优点：
             * 1.开闭原则
             * 2.避免使用多重条件转移语句
             * 3.提供算法的保密性和安全性
             *
             * 缺点：
             * 1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类
             * 2.产生很多策略类
        模板方法模式(template method):
             * 定义：
             * 1.定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现
             * 2.模板方法使得子类在不改变算法结构的情况下，重新定义算法的某些步骤
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.一次性实现一个算法不变的部分，并将可变部分留给子类实现
             * 2.各子类公共的行为被提取出来并集中到一个公共类，从而避免代码重复
             *
             * 优点：
             * 1.提高复用性
             * 2.提高扩展性
             * 3.符合开闭原则
             *
             * 缺点：
             * 1.类数目增加
             * 2.增加了系统实现的复杂度
             * 3.继承关系自身缺点，如果父类添加一个新的抽象方法，所有子类都要改一遍
        责任链模式(chain of responsibility)：
             * 1.为请求创建一个接收此次请求对象的链
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.一个请求的处理需要多个对象当中的一个或多个协同处理
             *
             * 优点：
             * 1.请求的发送者和接收者(请求的处理)解耦
             * 2.责任链可以动态组合
             *
             * 缺点：
             * 1.责任链太长或处理时间过长，影响性能
             * 2.责任链有可能过多
        状态模式(state):
             * 定义：
             * 1.允许一个对象在其内部状态改变时，改变它的行为
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.一个对象存在多个状态(不同状态下行为不同)，且状态可以相互转换
             *
             * 优点：
             * 1.将不同的状态隔离
             * 2.把各种状态的转换逻辑，分不到state的子类中，减少相互间依赖
             * 3.增加新的状态非常简单
             *
             * 缺点：
             * 1.状态多的场景导致类的数目增加，系统变复杂
        中介者模式(mediator)：
             * 1.定义一组封装一组对象如何交互的对象
             * 2.通过使对象明确地相互作用来促进松散耦合，并允许独立地改变他们的交互
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解
             * 2.交互的公共行为，如果需要改变行为则可以增加新的中介者类
             *
             * 优点：
             * 1.将一对多转成1对1，降低系统程序复杂度
             * 2.类之间解耦
             *
             * 缺点：
             * 1.中介者过多，导致系统复杂
        观察者模式(observer):
             * 定义：
             * 1.定义了对象之间一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者(观察者)都会收到通知并更新
             *
             * 类型：行为型
             *
             * 适用场景:
             * 1.关联行为场景，建立一套触发机制
             *
             * 优点：
             * 1.观察者与被观察者之间建立一个抽象的耦合
             * 2.观察者模式支持广播通信
             *
             * 缺点：
             * 1.观察者之间有过多的细节依赖、提高时间消耗及程序复杂度
             * 2.使用要得到，要避免循环调用
        迭代器模式(iterator):
             * 定义：
             * 1.提供一种方法，顺序访问一个集合对象中的各个元素，又不暴露该对象的内部表示
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.访问一个集合对象的内容而无需暴露它的内部表示
             * 2.为遍历不同的集合提供统一的接口
             *
             * 优点：
             * 1.分离了集合对象的遍历行为
             *
             * 缺点：
             * 1.类的个数成对增加
        解释器模式(interpreter):
             * 定义：
             * 1.给定一个语言，定义他的文法的一种表示，并定义一个解释器
             * 这个解释器使用该表示解释语言中的句子
             * 2.为了解释一种语言，而为语言创建的解释器
             *
             * 适用场景：
             * 1.某个特定类型问题发生频率足够高
             *
             * 优点：
             * 1.语法由很多类表示，容易改变及扩展此语言
             *
             * 缺点：
             * 1.语法规则数目太多，增加了系统复杂度
        备忘录模式(memento)：
             * 定义：
             * 1.保存一个对象的某个状态，以便在适当的时候恢复对象
             * 2."后悔药"
             *
             * 类型：行为型
             *
             * 适用场景
             * 1.保存及恢复数据相关业务
             * 2.后悔的时候，即想恢复到之前的状态
             *
             * 优点：
             * 1.为用户提供一种可恢复机制
             * 2.存档信息的封装
             *
             * 缺点：
             * 1.资源占用
        访问者模式(visitor)：
             * 定义
             * 1.封装作用于某数据结构(list/set/map等)中的各元素的操作
             * 2.可以在不改变各元素的的类的前提下，定义作用于这些元素的操作
             *
             *
             * 类型：行为型
             *
             * 适用场景：
             * 1.一个数据结构如(list/set/map等)包含很多类型对象
             * 2.数据结构与数据操作分离
             *
             * 优点：
             * 1.增加新的操作很容易，即增加一个新的访问者
             * 2.增加新的数据结构困难
             * 3.具体元素变更困难
        命令模式(command)：
             * 定义：将请求封装成对象，以便使用不同的请求
             * 命令模式解决了应用程序中对象的职责以及他们之间的通信方式
             *
             * 适用场景：
             * 1.请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互
             * 2.需要抽象出等待执行的行为
             *
             * 优点：
             * 1.降低耦合
             * 2.容易扩展新的命令或一组命令
             *
             * 缺点：
             * 1.命令的无限扩展会增加类的数量，提高系统实现复杂度
        
        
        

    
   
      
    
      



